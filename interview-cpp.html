<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"primemhd.tech","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面试中经常会用到的C++知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识：C++">
<meta property="og:url" content="https://primemhd.tech/interview-cpp.html">
<meta property="og:site_name" content="PrimeMHD House">
<meta property="og:description" content="面试中经常会用到的C++知识。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162834_union.png">
<meta property="og:image" content="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162856_cframe.png">
<meta property="og:image" content="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162913_virtualftable.png">
<meta property="og:image" content="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029163241_right.png">
<meta property="article:published_time" content="2019-09-22T13:40:15.000Z">
<meta property="article:modified_time" content="2020-10-29T08:33:10.000Z">
<meta property="article:author" content="Mi HD">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162834_union.png">

<link rel="canonical" href="https://primemhd.tech/interview-cpp.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>面试知识：C++ | PrimeMHD House</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6174f5c6f12162356a93b498b99bf251";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PrimeMHD House</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://primemhd.tech/interview-cpp.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mi HD">
      <meta itemprop="description" content="Truth and Transparency. 简单可依赖。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PrimeMHD House">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          面试知识：C++
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-22 21:40:15" itemprop="dateCreated datePublished" datetime="2019-09-22T21:40:15+08:00">2019-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-29 16:33:10" itemprop="dateModified" datetime="2020-10-29T16:33:10+08:00">2020-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/interview-cpp.html" class="post-meta-item leancloud_visitors" data-flag-title="面试知识：C++" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/interview-cpp.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/interview-cpp.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">面试中经常会用到的C++知识。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body><h1 id="C-专题复习"><span class="post-title-index">1. </span><a href="#C-专题复习" class="headerlink" title="C++专题复习"></a>C++专题复习</h1><h2 id="细碎知识"><span class="post-title-index">1.1. </span><a href="#细碎知识" class="headerlink" title="细碎知识"></a>细碎知识</h2><h3 id="C-的关键字"><span class="post-title-index">1.1.1. </span><a href="#C-的关键字" class="headerlink" title="C++的关键字"></a>C++的关键字</h3><h4 id="static"><span class="post-title-index">1.1.1.1. </span><a href="#static" class="headerlink" title="static"></a><code>static</code></h4><ul>
<li><p><strong>改变作用域（隐藏）</strong></p>
<p><code>全局变量</code>分为<code>静态全局变量</code>和<code>外部全局变量</code>。</p>
<p>加上static后对其他源文件隐藏，只在本源文件内有效。</p>
</li>
</ul>
<ul>
<li><p><strong>改变生存期</strong></p>
<p>使用static生命的变量会在<code>静态/全局存储区</code>，会在程序刚开始就完成初始化，生存期为整个程序。但是对于静态局部变量而言，其作用域还是局部变量的作用域。</p>
<a id="more"></a></li>
<li><p><strong>赋值0</strong></p>
<p>普通局部变量如果未初始化，其值不可预测。加上static后，内存在<code>静态/全局存储区</code>，会赋初值为0。</p>
</li>
<li><p><strong>！！！特殊，类成员生命为static</strong></p>
<p>在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p>
<p>​    <strong>静态成员函数</strong></p>
<ul>
<li><p>类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。</p>
</li>
<li><p>不能将静态成员函数定义为虚函数。      </p>
</li>
<li><p>由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  </p>
</li>
<li><p>static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。 </p>
<p><strong>静态数据成员</strong>     </p>
</li>
<li><p>静态数据成员在<定义或说明>时前面加关键字static。   </p>
</li>
<li><p>由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。  </p>
</li>
<li><p>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，不能再定义时初始化） </p>
<ul>
<li>为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>另一种概括：</p>
<ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
</blockquote>
<h4 id="const"><span class="post-title-index">1.1.1.2. </span><a href="#const" class="headerlink" title="const"></a><code>const</code></h4><p><strong>1. const指针</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">作用（含义）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指向常量的指针</td>
<td style="text-align:center">const int <em>p;<br>int const </em>p;</td>
<td style="text-align:center">只能通过该指针<strong>访问</strong>变量，不能<strong>修改</strong>该变量。另外，只有指向常量的指针可以指向常量，普通指针不可以。</td>
</tr>
<tr>
<td style="text-align:center">常指针</td>
<td style="text-align:center">int * const p;</td>
<td style="text-align:center">可以通过指针修改变量的值；<br>必须定义时初始化，不能变心；<br>p++这种操作是不允许的</td>
</tr>
<tr>
<td style="text-align:center">指向常量的常指针</td>
<td style="text-align:center">const int * const p;</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2. 常对象</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const 类名 对象名(初始化实参表);</span></span><br><span class="line"><span class="comment">//类名 const 对象名(初始化实参表) </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Time <span class="title">t1</span><span class="params">(<span class="number">15</span>,<span class="number">23</span>,<span class="number">55</span>)</span></span>;</span><br><span class="line"><span class="function">Time <span class="keyword">const</span> <span class="title">t2</span><span class="params">(<span class="number">15</span>,<span class="number">24</span>,<span class="number">55</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>常对象，必须在定义时初始化。</li>
<li>整个程序执行过程中，值不能变化</li>
<li>==常对象不能调用普通成员函数（即使不改变成员的值）==</li>
<li>常对象，只能调用常成员函数。</li>
</ul>
<p>常对象的约束可能过于严格。可以使用<code>常数据成员</code>或<code>常成员函数</code></p>
<p><strong>3. 常数据成员</strong>  </p>
<ul>
<li>常数据成员要遭构造函数中初始化，且使用中值不可变。</li>
<li>==常数据成员的构造函数，必须用<strong>参数初始化表</strong>,不能用赋值的方式==。构造函数中，非成员成员变量可以用赋值的方式。</li>
</ul>
<p><strong>4. 常成员函数</strong></p>
<ul>
<li><p>常成员函数可以调用本类的另一个常成员函数，但是不能调用本类的非常成员函数（即使他什么都没做）</p>
</li>
<li><p>常成员函数只能引用类的数据成员，不能修改（==除非是加了mutable的数据成员==）</p>
</li>
<li>==常成员函数声明时的const必须写在最后==</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>{</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">const</span> hour;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> second;</span><br><span class="line">        <span class="comment">//这两种都行,等价</span></span><br><span class="line">        Time(<span class="keyword">int</span> h,<span class="keyword">int</span> m,<span class="keyword">int</span> s):hour(h),minute(m){</span><br><span class="line">            second=s;</span><br><span class="line">            <span class="comment">//hour和minute是常数据成员，必须用参数初始化表</span></span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showHour</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//加了const，在该函数中只能引用成员的值，不能修改</span></span><br><span class="line">        <span class="comment">//const必须写在后面</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>5. 一个非常全的例子</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) { };</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) { };        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>& Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="this"><span class="post-title-index">1.1.1.3. </span><a href="#this" class="headerlink" title="this"></a><code>this</code></h4><ul>
<li><code>this</code>指针不占类的空间，也不占对象的空间（即sizeof不包括进去）。因为<code>this</code>指针是在<code>成员函数</code>中的，它隐含于每一个非静态成员函数中，指向调用该成员函数的那个的对象。</li>
<li><code>this</code>指针被隐含的声明为<code>ClassName *const this</code>，意味着<code>this</code>指针是一个常指针，不能修改<code>this</code>指针的值。</li>
<li>在类的<code>常成员函数</code>中，<code>this</code>指针被声明为<code>指向常量的常指针</code>,即<code>ClassName const * const this</code>，说明在常成员函数中，不能通过<code>this</code>指针修改对象。</li>
</ul>
<h4 id="inline"><span class="post-title-index">1.1.1.4. </span><a href="#inline" class="headerlink" title="inline"></a><code>inline</code></h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>==在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。==</li>
</ul>
<h4 id="volatile"><span class="post-title-index">1.1.1.5. </span><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h4><ul>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h4 id="pragma-pack-n"><span class="post-title-index">1.1.1.6. </span><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a><code>#pragma pack(n)</code></h4><p>设置对其方式</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)<span class="comment">//保存现有的对其方式，以便之后恢复</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)<span class="comment">//设置四字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>{</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop) <span class="comment">//恢复对其方式</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="extern-quot-C-quot"><span class="post-title-index">1.1.1.7. </span><a href="#extern-quot-C-quot" class="headerlink" title="extern "C""></a><code>extern "C"</code></h4><ul>
<li>被 <code>extern "C"</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="union共用体-和机器大小端"><span class="post-title-index">1.1.1.8. </span><a href="#union共用体-和机器大小端" class="headerlink" title="union共用体(和机器大小端)"></a><code>union共用体(和机器大小端)</code></h4><ul>
<li><p>所有成员从同一内存开始，union共用体的大小为其中占空间最大的成员的大小。</p>
</li>
<li><p>给共用体的一个成员赋值之后，会覆盖其他成员的值，因此只有最后一次存放的成员是有效的。</p>
<p><img data-src="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162834_union.png" alt="1567838897988"></p>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过union来判断机器是大端序还是小端序*/</span></span><br><span class="line"><span class="keyword">union</span> data{</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> data d;</span><br><span class="line">d.a=<span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">if</span>(d.b==<span class="number">0x11</span>){</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"大端序"</span><<<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(d.b==<span class="number">0x44</span>){</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"小端序"</span><<<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"这段程序错误"</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>判断机器的大小端类型，还可以用下面的方法：</p>
<ul>
<li>指针法</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">char</span> *p_c=(<span class="keyword">char</span> *)&a;</span><br><span class="line"><span class="keyword">if</span>(*p_c==<span class="number">0x11</span>){</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"大端序"</span><<<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(*p_c==<span class="number">0x44</span>){</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"小端序"</span><<<span class="built_in">endl</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"这段程序错误！"</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>参数传递法</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judgeBigLittle</span><span class="params">(<span class="keyword">char</span> c)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="number">0x44</span>){</span><br><span class="line">        <span class="built_in">cout</span><<<span class="string">"小端序"</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">cout</span><<<span class="string">"大端序"</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line">judege(a);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="enum枚举类型"><span class="post-title-index">1.1.1.9. </span><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a><code>enum枚举类型</code></h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week{Monday,Tuesday};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>枚举类型是常量，按照整形常量处理。但是不能用常量直接赋值，要做强制类型转换。</li>
</ul>
<h4 id="explicit"><span class="post-title-index">1.1.1.10. </span><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h4><p><code>explicit</code>的中文意思是<code>显式</code>。</p>
<ul>
<li>用explicit修饰构造函数的时候，可以防止隐式转换和复制初始化</li>
<li>用explicit修饰转换函数的时候，可以防止隐式转，但<code>按语境转换</code>除外</li>
</ul>
<h4 id="sizeof"><span class="post-title-index">1.1.1.11. </span><a href="#sizeof" class="headerlink" title="sizeof()"></a><code>sizeof()</code></h4><ul>
<li><p>sizeof(数组)：数组所占空间大小</p>
</li>
<li><p>sizeof(指针)：指针所占空间的大小</p>
<p>==有关对象的sizeof还需要讨论==</p>
</li>
</ul>
<h4 id="friend"><span class="post-title-index">1.1.1.12. </span><a href="#friend" class="headerlink" title="friend"></a><code>friend</code></h4><h4 id="exit"><span class="post-title-index">1.1.1.13. </span><a href="#exit" class="headerlink" title="exit()"></a><code>exit()</code></h4><h4 id="using"><span class="post-title-index">1.1.1.14. </span><a href="#using" class="headerlink" title="using"></a><code>using</code></h4><h4 id="try-catch"><span class="post-title-index">1.1.1.15. </span><a href="#try-catch" class="headerlink" title="try catch"></a><code>try catch</code></h4><h4 id="size-t"><span class="post-title-index">1.1.1.16. </span><a href="#size-t" class="headerlink" title="size_t"></a><code>size_t</code></h4><h4 id="NULL"><span class="post-title-index">1.1.1.17. </span><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h4><h3 id="C-的内存分布"><span class="post-title-index">1.1.2. </span><a href="#C-的内存分布" class="headerlink" title="C++的内存分布"></a>C++的内存分布</h3><blockquote>
<p>复习C的内存分布：（按照逻辑地址从低到高）</p>
<ol>
<li>代码段</li>
<li>BSS段：存放未初始化的全局变量</li>
<li>数据段：静态内存分配，用于存放已初始化的全局变量</li>
<li>堆：存放进程运行中被动态分配的内存段，malloc/free在这上面进行。</li>
<li>栈：存放程序运行的函数栈帧。</li>
</ol>
</blockquote>
<p><strong>C++的内存分布共有5大块</strong></p>
<ul>
<li>代码段：这部分与C程序是大致相同的；</li>
<li>常量存储区：这部分存储的内容与C语言中初始化数据段中的只读数据段是一样的，用来存储C++常量；</li>
<li>全局/静态存储区：在C++中，不再区分数据段和BSS段，未初始化和初始化的全局/静态变量都会存储在这里，并且初始化为0；</li>
<li>堆：堆又分为new分配的存储区和malloc分配的内存块，new分配的存储区会在程序结束之后，系统会帮助我们清理；</li>
<li>栈：栈和C程序的栈相同。<br>C和C++的内存布局大致上是相同的，主要区别在于C++引进了对象，C++对象中的成员函数存储在代码段中，数据成员才会存储在栈中，同样静态变量会存储在在全局/静态存储区，并且必须初始化。当然C++对象内存布局会涉及到继承，多态而出现多种变化，以及内存对齐的影响。</li>
</ul>
<p><strong>C函数栈帧的样子</strong></p>
<p><img data-src="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162856_cframe.png" alt="1568560299990" style="zoom:50%;"></p>
<h3 id="C-中的变量"><span class="post-title-index">1.1.3. </span><a href="#C-中的变量" class="headerlink" title="C++中的变量"></a>C++中的变量</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">内存位置</th>
<th style="text-align:center">生存期</th>
<th style="text-align:center">作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">静态局部变量</td>
<td style="text-align:center">全局/静态存储区</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">静态全局变量</td>
<td style="text-align:center">全局/静态存储区</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">外部全局变量</td>
<td style="text-align:center">全局/静态存储区</td>
<td style="text-align:center"></td>
<td style="text-align:center">所有源文件可访问，但要用extern声明</td>
</tr>
<tr>
<td style="text-align:center">局部变量</td>
<td style="text-align:center">堆区or栈区</td>
<td style="text-align:center"></td>
<td style="text-align:center">代码块内</td>
</tr>
</tbody>
</table>
</div>
<h3 id="操作符重载"><span class="post-title-index">1.1.4. </span><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="成员函数运算符重载"><span class="post-title-index">1.1.4.1. </span><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">形式：</span><br><span class="line">返回类型 <span class="keyword">operator</span> 运算符(形参表){</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="友元函数运算符重载"><span class="post-title-index">1.1.4.2. </span><a href="#友元函数运算符重载" class="headerlink" title="友元函数运算符重载"></a>友元函数运算符重载</h4><p>如果双目运算符的第一个参数不是对象，就不能用成员函数进行运算符的重载。</p>
<h3 id="条件编译"><span class="post-title-index">1.1.5. </span><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h3 id="浅拷贝与深拷贝（赋值与复制）"><span class="post-title-index">1.1.6. </span><a href="#浅拷贝与深拷贝（赋值与复制）" class="headerlink" title="浅拷贝与深拷贝（赋值与复制）"></a>浅拷贝与深拷贝（赋值与复制）</h3><ul>
<li><p><strong>浅拷贝</strong></p>
<p><code>浅拷贝</code>又叫<code>赋值</code>，简单粗暴相当于把内存直接拷贝；</p>
<p>在未定义<code>拷贝构造函数</code>的情况下，系统会调用默认的拷贝函数进行<code>浅拷贝</code>。</p>
<p>如果数据成员中没有指针，浅拷贝也不是不可以。但是如果有动态内存申请的话，后果不可预料。</p>
</li>
<li><p><strong>深拷贝</strong></p>
<p><code>深拷贝</code>又叫<code>复制</code>，会在堆内存中申请空间来存储数据，拷贝的指针会赋新的值。</p>
</li>
</ul>
<h3 id="可变参数列表"><span class="post-title-index">1.1.7. </span><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><h2 id="类与对象专题"><span class="post-title-index">1.2. </span><a href="#类与对象专题" class="headerlink" title="类与对象专题"></a>类与对象专题</h2><h3 id="小知识"><span class="post-title-index">1.2.1. </span><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><ul>
<li><p><code>成员函数</code>的<strong>体内实现</strong>缺省为inline。是否inline由编译器决定。</p>
</li>
<li><p>sizeof(类)=所有数据成员之和。并不包含隐藏的this指针。sizeof(空类)=1</p>
</li>
</ul>
<h3 id="构造函数"><span class="post-title-index">1.2.2. </span><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="数据成员的初始化"><span class="post-title-index">1.2.2.1. </span><a href="#数据成员的初始化" class="headerlink" title="数据成员的初始化"></a>数据成员的初始化</h4><p>① 仿照<code>结构体</code>的方法，使用大括号</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s1={<span class="string">"MiHaodong"</span>,<span class="number">12</span>,<span class="string">"male"</span>};</span><br></pre></td></tr></tbody></table></figure>
<p>② 写一个赋初始值的<code>public</code>方法，再其他成员被使用之前调用</p>
<p>③ 新版的C++允许在声明时初始化。==static数据成员不可以！==</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> year=<span class="number">2019</span>;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>④ 正宗的方法，应当是通过<code>构造函数</code></p>
<ul>
<li><p>构造函数必须是<code>public</code>.如果定义了构造函数，则无参空体不复存在，不构成重载。</p>
</li>
<li><p><code>初始化形参表</code>，==const数据成员，只能用初始化形参表的方式==</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s): hour(h), minute(m), second(s){}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="构造函数的调用"><span class="post-title-index">1.2.2.2. </span><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">12</span>,<span class="number">34</span>,<span class="number">55</span>)</span></span>; <span class="comment">//隐式调用，栈上分配</span></span><br><span class="line">Time t1{<span class="number">12</span>,<span class="number">34</span>,<span class="number">55</span>}; <span class="comment">//跟上面的一样，隐式调用，栈上分配</span></span><br><span class="line">Time t2=Time(<span class="number">12</span>,<span class="number">34</span>,<span class="number">55</span>);<span class="comment">//显式调用，栈上分配</span></span><br><span class="line">Time t3=<span class="keyword">new</span> Time(<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>);<span class="comment">//显示调用，堆上分配</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>构造函数的调用时机</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">调用时机</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自动对象（形参）</td>
<td style="text-align:center">函数中变量定义的时候</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">静态局部对象<br>static Student</td>
<td style="text-align:center">第一次使用的时候</td>
<td style="text-align:center">静态局部对象在内存中的<code>静态/全局存储区</code></td>
</tr>
<tr>
<td style="text-align:center">静态/外部全局对象</td>
<td style="text-align:center">程序开始，main函数执行之前</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">new对象</td>
<td style="text-align:center">new的时候</td>
<td style="text-align:center">流程为：申请空间→调用构造函数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>复制（拷贝）构造函数</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">12</span>,<span class="number">34</span>,<span class="number">55</span>)</span></span>;  <span class="comment">//隐式调用普通构造函数</span></span><br><span class="line"></span><br><span class="line">Time t2=t1;</span><br><span class="line"><span class="function">Time <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">Time t2=<span class="keyword">new</span> Time(t1);</span><br><span class="line"><span class="comment">//情形1：用已有对象初始化一个新的对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showObj</span><span class="params">(Time t)</span></span>{</span><br><span class="line">    t.show();</span><br><span class="line">}</span><br><span class="line">showObj(t1);</span><br><span class="line"><span class="comment">//情形2：函数形参为对象，实参向形参传值的时候</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retDemo</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">12</span>,<span class="number">23</span>,<span class="number">44</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//情形3：函数的返回值为对象的时候</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>转换构造函数</strong></li>
</ul>
<h3 id="析构函数"><span class="post-title-index">1.2.3. </span><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="析构函数注意问题"><span class="post-title-index">1.2.3.1. </span><a href="#析构函数注意问题" class="headerlink" title="析构函数注意问题"></a>析构函数注意问题</h4><h4 id="析构函数的调用时机"><span class="post-title-index">1.2.3.2. </span><a href="#析构函数的调用时机" class="headerlink" title="析构函数的调用时机"></a>析构函数的调用时机</h4><h2 id="继承派生专题"><span class="post-title-index">1.3. </span><a href="#继承派生专题" class="headerlink" title="继承派生专题"></a>继承派生专题</h2><h3 id="虚函数"><span class="post-title-index">1.3.1. </span><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="空虚函数"><span class="post-title-index">1.3.1.1. </span><a href="#空虚函数" class="headerlink" title="- 空虚函数"></a>- <code>空虚函数</code></h4><blockquote>
<p>在类的继承层次中，派生类都由同名函数，而基类没有。为了使用虚函数的机制，在基类中定义一个同名的<code>空虚函数</code>，从而建立一条从基类到派生类的虚函数路径。</p>
</blockquote>
<h4 id="纯虚函数与抽象类"><span class="post-title-index">1.3.1.2. </span><a href="#纯虚函数与抽象类" class="headerlink" title="- 纯虚函数与抽象类"></a>- <code>纯虚函数</code>与<code>抽象类</code></h4><blockquote>
<p>无中生有地定义个抽象类，无实际意义，不进行具体操作。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纯虚函数的写法</span></span><br><span class="line"><span class="comment">//virtual 返回类型 函数名(形参表)=0;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstructClass</span>{</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>抽象类不能实例化，但是可以声明指针或者引用</strong></p>
<h4 id="虚函数表"><span class="post-title-index">1.3.1.3. </span><a href="#虚函数表" class="headerlink" title="- 虚函数表"></a>- <code>虚函数表</code></h4><blockquote>
<p>虚函数表是编译器在<code>编译时期</code>为我们创建好的，只存在一份。定义类的对象的时候，编译器自动将对象的<code>__vfptr</code>指向这个虚函数表。 </p>
<p>含有虚函数的类，其对象中包含一个<code>_vfptr</code>，这是一个<code>指向数组（即虚函数表）的指针</code></p>
</blockquote>
<p><strong>一个类的不同对象，共用一份虚函数表。 </strong></p>
<p><img data-src="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029162913_virtualftable.png" alt="1568601998932"></p>
<h2 id="STL专题"><span class="post-title-index">1.4. </span><a href="#STL专题" class="headerlink" title="STL专题"></a>STL专题</h2><h3 id="分类"><span class="post-title-index">1.4.1. </span><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>顺序容器(Sequence Container)</p>
<ul>
<li><p>Array <code>定长数组</code></p>
<blockquote>
<p>定长的数组。将C++的数组包装成一个Class.</p>
</blockquote>
</li>
<li><p>Vector <code>单向扩充数组</code></p>
<blockquote>
<p>可变数组，起点不能动，尾部可以扩充，会自动增长（由Allocator做）.</p>
</blockquote>
</li>
<li><p>Deque <code>双向扩充数组</code></p>
</li>
<li><p>List <code>双向链表</code></p>
<blockquote>
<p>STL的List是双向的链表。</p>
</blockquote>
</li>
<li><p>Forward-List <code>单向链表</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>关联容器（Associative Container）</li>
</ul>
<ul>
<li>不定序容器（Unordered Container）（特殊的注：候说这也是一种关联容器）</li>
</ul>
<h3 id="string类"><span class="post-title-index">1.4.2. </span><a href="#string类" class="headerlink" title="string类"></a>string类</h3><h4 id="sizeof-1"><span class="post-title-index">1.4.2.1. </span><a href="#sizeof-1" class="headerlink" title="sizeof"></a>sizeof</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"abc13344"</span>;</span><br><span class="line"><span class="built_in">cout</span><<<span class="keyword">sizeof</span>(a)<<<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span><<<span class="keyword">sizeof</span>(<span class="built_in">string</span>)<<<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//结果是28（或者4，与编译器有关）</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="string长度"><span class="post-title-index">1.4.2.2. </span><a href="#string长度" class="headerlink" title="string长度"></a>string长度</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cout</span><<<span class="string">"字符的个数为（不含\0）："</span><<s.length();</span><br><span class="line"><span class="built_in">cout</span><<<span class="string">"字符的个数为（不含\0）："</span><<s.<span class="built_in">size</span>();</span><br></pre></td></tr></tbody></table></figure>
<h3 id="序列容器"><span class="post-title-index">1.4.3. </span><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><h3 id="关联容器"><span class="post-title-index">1.4.4. </span><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><h2 id="内存-amp-指针专题"><span class="post-title-index">1.5. </span><a href="#内存-amp-指针专题" class="headerlink" title="内存&指针专题"></a>内存&指针专题</h2><h3 id="指针和引用"><span class="post-title-index">1.5.1. </span><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><h4 id="引用"><span class="post-title-index">1.5.1.1. </span><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li>引用相当于变量的别名；</li>
<li>引用不分配单独的空间；</li>
<li>引用需要在声明时初始化，并在整个生存期内不指向其他变量；</li>
<li>==✖==数组的引用，==✖==引用的数组，==✖==指向引用的指针，以上均不合法；</li>
<li>==✔==指向数组元素的引用，==✔==指针的引用；</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> 稍后再补充</span><br></pre></td></tr></tbody></table></figure>
<h4 id="左值-右值引用"><span class="post-title-index">1.5.1.2. </span><a href="#左值-右值引用" class="headerlink" title="左值/右值引用"></a>左值/右值引用</h4><ul>
<li><p><strong>左值/右值的定义</strong></p>
<p><code>lvalue</code>又叫做<code>左值</code>，代表一个在内存中占有确定位置的对象。</p>
<p><code>rvalue</code>又叫做<code>右值</code>，代表在内存中不占有确定的位置。</p>
</li>
<li><p><strong>C++11中新定义了右值引用</strong></p>
<p>临时对象即将消亡，但里面的数据还是要用的，所以用移动构造</p>
<p><img data-src="https://miimages.oss-cn-hangzhou.aliyuncs.com/imgs/20201029163241_right.png" alt="image-20201029163233846" style="zoom:50%;"></p>
</li>
</ul>
<h4 id="移动语义"><span class="post-title-index">1.5.1.3. </span><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><ul>
<li><strong>移动构造函数/移动赋值运算符</strong></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*移动构造函数*/</span></span><br><span class="line">A(A&& other) <span class="keyword">noexcept</span>    </span><br><span class="line"><span class="comment">// C++11 - specifying non-exception throwing functions</span></span><br><span class="line">{</span><br><span class="line">  mData =  other.mData;  <span class="comment">// shallow copy or referential copy</span></span><br><span class="line">  other.mData = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*移动赋值运算符*/</span></span><br><span class="line">A& <span class="keyword">operator</span>=(A&& other) <span class="keyword">noexcept</span>{</span><br><span class="line">    mData=other.mdata;</span><br><span class="line">    other.mData=nullPtr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>std::move()</strong></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> foo = <span class="string">"foo-string"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> bar = <span class="string">"bar-string"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="built_in">std</span>::<span class="built_in">string</span>> myvector;</span><br><span class="line"></span><br><span class="line">  myvector.push_back (foo);                    <span class="comment">// copies</span></span><br><span class="line">  myvector.push_back (<span class="built_in">std</span>::move(bar));         <span class="comment">// moves</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>& x:myvector) <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">' '</span> << x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>The first call to <code>myvector.push_back</code> copies the value of foo into the vector (foo keeps the value it had before the call).<br>The second call moves the value of bar into the vector. This transfers its content into the vector (while bar loses its value, and now is in a valid but unspecified state).</p>
</blockquote>
<h3 id="动态内存分配与管理"><span class="post-title-index">1.5.2. </span><a href="#动态内存分配与管理" class="headerlink" title="动态内存分配与管理"></a>动态内存分配与管理</h3><h4 id="malloc、calloc、realloc"><span class="post-title-index">1.5.2.1. </span><a href="#malloc、calloc、realloc" class="headerlink" title="malloc、calloc、realloc"></a>malloc、calloc、realloc</h4><ul>
<li>malloc申请的内存区域，保持原样不做初始化</li>
<li>calloc与malloc的区别是不仅申请区域，还对申请的内存进行0化</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(p,data,<span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">nullptr</span>; <span class="comment">//这一步如果不做的话，p还是会保持一个值</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>==如果用malloc动态申请一个对象，需要显示调用构造函数、析构函数。==</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time *p_time=(Time *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Time));</span><br><span class="line"><span class="keyword">new</span>(p_time)Time();</span><br><span class="line"><span class="comment">/////////////////////////</span></span><br><span class="line">p_time->~Time();</span><br><span class="line"><span class="built_in">free</span>(p_time);</span><br></pre></td></tr></tbody></table></figure>
<p>比较麻烦，所以一般不推荐使用malloc创建对象。</p>
<h4 id="new、delete"><span class="post-title-index">1.5.2.2. </span><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ul>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student *p_stu=<span class="keyword">new</span> Student;</span><br><span class="line">Student *p_stu=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//对于有构造函数的类，不论有没有括号，都用构造函数进行初始化；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，</span></span><br><span class="line"><span class="comment">//而加了括号的new会在分配内存的同时初始化为0。</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>delete可以用在malloc创建出的对象上吗？</p>
</blockquote>
<h4 id="operator-new和new-operator的区别"><span class="post-title-index">1.5.2.3. </span><a href="#operator-new和new-operator的区别" class="headerlink" title="operator new和new operator的区别"></a>operator new和new operator的区别</h4><ul>
<li><strong>new operator</strong></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//这是new operator</span></span><br></pre></td></tr></tbody></table></figure>
<p>​    new operator做的事情：分配内存+调用构造函数（如果有）初始化。</p>
<ul>
<li><p><strong>operator new</strong></p>
<p>operator new是完成内存分配的操作符（类似于malloc），它只对内存分配负责，对构造函数一无所知。</p>
<p>==重载operator new== </p>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="限定对象只能在堆上（栈上）"><span class="post-title-index">1.5.2.4. </span><a href="#限定对象只能在堆上（栈上）" class="headerlink" title="限定对象只能在堆上（栈上）"></a>限定对象只能在堆上（栈上）</h4><ul>
<li><p><strong>只能在栈上</strong></p>
<p><strong>方法：</strong>将new、delete重载为私有</p>
<p><strong>原因：</strong>在堆上创建对象分两步 分配空间->调用构造函数初始化。new私有之后，第一步就无法进行。</p>
</li>
<li><p><strong>只能在堆上</strong></p>
<p><strong>方法：</strong>将析构函数设置为<code>private</code></p>
<p><strong>原因：</strong>编译器在为类对象分配栈空间的时候，会检查析构函数的可访问性，如果不可访问的话，就不能在栈上创建对象。</p>
</li>
</ul>
<h3 id="智能指针"><span class="post-title-index">1.5.3. </span><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="为什么需要智能指针"><span class="post-title-index">1.5.3.1. </span><a href="#为什么需要智能指针" class="headerlink" title="为什么需要智能指针"></a>为什么需要智能指针</h4><blockquote>
<p>为了防止程序还没有执行到delete就跳转了，或者函数在没有执行到最后的delete语句就返回了。如果我们没有在每一个可能返回或者跳转的地方提前释放资源，就会造成内存泄漏</p>
<p>智能指针是一个类，当超出类的作用域的时候，会自动调用析构函数，从而释放资源。</p>
</blockquote>
<h4 id="auto-ptr-被c-11弃用"><span class="post-title-index">1.5.3.2. </span><a href="#auto-ptr-被c-11弃用" class="headerlink" title="auto_ptr(被c++11弃用)"></a>auto_ptr(被c++11弃用)</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><memory></span></span></span><br><span class="line"><span class="built_in">auto_ptr</span><Test>p_auto(<span class="keyword">new</span> Test(<span class="string">"hello"</span>));</span><br><span class="line">Test* p_test=p_auto.get();  <span class="comment">//获得auto_ptr管理的对象的指针</span></span><br><span class="line">p_auto.reset(<span class="keyword">new</span> Test(<span class="string">"i am new obj"</span>)); <span class="comment">//这步先new一个新的对象，会调新对象的构造函数。在执行到reset函数的时候，重新绑定对象会将原来管理的对象析构掉。</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>auto_ptr进行赋值的时候，如ptest2=ptest1，ptest2会接管原先ptest1管理的内存，若ptest2原先不为空指针则需要释放原先管理的，ptest1就成了空指针。</li>
<li>判断一个auto_ptr是否为空，应该用<code>if (ptest.get()==NULL)</code></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_auto.reset();<span class="comment">//提前释放p_auto管理的内存</span></span><br><span class="line">p_auto.release();<span class="comment">//撤销管理权，不释放内存（可能会存在内存泄漏）</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="unique-ptr"><span class="post-title-index">1.5.3.3. </span><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><ul>
<li><code>unique_ptr</code>是独享所有权的智能指针，无法让两个unique_ptr指向同一个对象</li>
<li><code>unique_ptr</code>无法进行复制构造，无法进行赋值复制。</li>
<li><code>unique_ptr</code>除了<code>auto_ptr</code>的功能之外，还有别的功能：<ul>
<li>将动态申请内存的所有权传递给某个函数</li>
<li>从某个函数返回动态申请内存的所有权</li>
<li>在容器中使用<code>unique_ptr</code></li>
<li>为动态申请的内存提供异常安全</li>
</ul>
</li>
<li><code>unique_ptr</code>和<code>auto_ptr</code>的用法非常相似，特别注意一下<code>区别</code>:<ul>
<li>unique_p2=unique_p2的用法是不可以的，需要用std::move</li>
<li>可以用<code>if(p_unique==NULL)</code>来判断是否为空指针，这点是<code>auto_ptr</code>做不到的</li>
<li><strong>并不是说=一定不能用于unique_ptr，譬如作为函数返回值赋值可以使用=</strong></li>
<li><code>unique_ptr</code>作为实参进行船只的时候，要这样foo(std::move(p_unique));</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span><<span class="built_in">string</span>> <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"auto"</span>))</span></span>;           </span><br><span class="line"><span class="built_in">unique_ptr</span><<span class="built_in">string</span>> p4；</span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span><<span class="built_in">string</span>> <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span><<span class="built_in">string</span>> pu2;</span><br><span class="line">pu2 = pu1;    <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span><<span class="built_in">string</span>> pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span><<span class="built_in">string</span>>(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="shared-ptr"><span class="post-title-index">1.5.3.4. </span><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><h4 id="weak-ptr"><span class="post-title-index">1.5.3.5. </span><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><h3 id="移动语义-1"><span class="post-title-index">1.5.4. </span><a href="#移动语义-1" class="headerlink" title="移动语义"></a>移动语义</h3><blockquote>
<p><code>移动</code>和<code>拷贝</code>的区别是什么呢？</p>
</blockquote>
<h2 id="泛型编程"><span class="post-title-index">1.6. </span><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><h3 id="函数模板"><span class="post-title-index">1.6.1. </span><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h3 id="类模板"><span class="post-title-index">1.6.2. </span><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h2 id="C-多线程"><span class="post-title-index">1.7. </span><a href="#C-多线程" class="headerlink" title="C++多线程"></a>C++多线程</h2><h3 id="phtread"><span class="post-title-index">1.7.1. </span><a href="#phtread" class="headerlink" title="phtread"></a>phtread</h3><h2 id="字符串"><span class="post-title-index">1.8. </span><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="数据结构-amp-类"><span class="post-title-index">1.8.1. </span><a href="#数据结构-amp-类" class="headerlink" title="数据结构&类"></a>数据结构&类</h3><h4 id="char-和char"><span class="post-title-index">1.8.1.1. </span><a href="#char-和char" class="headerlink" title="char[ ]和char*"></a>char[ ]和char*</h4><h4 id="string类-1"><span class="post-title-index">1.8.1.2. </span><a href="#string类-1" class="headerlink" title="string类"></a>string类</h4><ul>
<li><p><strong>访问/遍历字符</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问第i个字符（从0开始）</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"1234567"</span>)</span></span>;</span><br><span class="line">str.at(i);</span><br><span class="line">str[i];</span><br><span class="line">str.front();<span class="comment">//第一个</span></span><br><span class="line">str.back(); <span class="comment">//最后一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历每个字符的方法</span></span><br><span class="line"><span class="comment">//方法1：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span>& c:str){</span><br><span class="line">    <span class="comment">//do sth</span></span><br><span class="line">}</span><br><span class="line">注意区别：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:str){</span><br><span class="line">	<span class="comment">//do sth</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=str.begin();it!=str.end();it++){</span><br><span class="line">	<span class="comment">// 对*it做什么</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<str.size();i++){</span><br><span class="line">	<span class="built_in">cout</span><<str[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>查看string属性</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="comment">//查看字符串的长度（不包含\0）</span></span><br><span class="line">s.size();</span><br><span class="line">s.length();</span><br><span class="line"><span class="comment">//容量相关（类似vector，空间也是动态申请的）</span></span><br><span class="line">s.capacity();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>修改string</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="comment">//1.增</span></span><br><span class="line">s.push_back(<span class="string">'c'</span>);<span class="comment">//末尾添加字符</span></span><br><span class="line">s.append(<span class="string">"abc"</span>);<span class="comment">//末尾添加字符串</span></span><br><span class="line">s.append(<span class="number">1</span>,<span class="string">'a'</span>);<span class="comment">//末尾添加n个字符，必须指定个数</span></span><br><span class="line">s.insert(pos,<span class="built_in">string</span>); <span class="comment">//在第pos位置之前插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.改</span></span><br><span class="line">通过前面的“访问字符”方法，可以直接修改单个字符</span><br><span class="line">s.replace(startPos,n_len,str);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.删</span></span><br><span class="line">s.erase(pos,len);<span class="comment">//删除若干个字符</span></span><br><span class="line">s.clear();<span class="comment">//直接清空字符</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>从string中取子串</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将string转化为char*</span></span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"123456"</span>;</span><br><span class="line"><span class="keyword">char</span> *cstr=s.c_str();</span><br><span class="line"><span class="keyword">char</span> *cstr=s.data();</span><br><span class="line"></span><br><span class="line"><span class="comment">//string.substr()方法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="字符串处理函数str"><span class="post-title-index">1.8.2. </span><a href="#字符串处理函数str" class="headerlink" title="字符串处理函数str"></a>字符串处理函数str</h3><ul>
<li><p><strong>头文件</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><cstring></span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><string.h></span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>strcpy、strncpy</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">char</span> s[],<span class="keyword">const</span> <span class="keyword">char</span> t[]); </span><br><span class="line"><span class="comment">//将字符串t复制到字符串s中，覆盖原串</span></span><br><span class="line"><span class="built_in">strncpy</span>(<span class="keyword">char</span> s[],<span class="keyword">const</span> <span class="keyword">char</span> t[]);</span><br><span class="line"><span class="comment">//将字符串t的前n个字符复制到字符串s中。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>strcat、strncat</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(<span class="keyword">char</span> s[],<span class="keyword">const</span> <span class="keyword">char</span> t[]);</span><br><span class="line"><span class="comment">//将字符串t的内容接在s尾部</span></span><br><span class="line"><span class="built_in">strncat</span>(<span class="keyword">char</span> s[],<span class="keyword">const</span> <span class="keyword">char</span> t[]);</span><br><span class="line"><span class="comment">//将字符串t的前n个字符接在字符串s的尾部</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>strcmp、strncmp</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(<span class="keyword">const</span> <span class="keyword">char</span> s[],<span class="keyword">const</span> <span class="keyword">char</span> t[]);</span><br><span class="line"><span class="comment">//对比两个字符串是否对应相等。相等则返回0</span></span><br><span class="line"><span class="built_in">strncmp</span>(<span class="keyword">const</span> <span class="keyword">char</span> s[],<span class="keyword">const</span> <span class="keyword">char</span> t[],n);</span><br><span class="line"><span class="comment">//对比两个字符串的前n个字符的大小</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>strlen</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> s[]);</span><br><span class="line"><span class="comment">//返回第一个'\0'前的字符数量（不含）。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>memcpy、memcmp、memset</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst,<span class="keyword">void</span> *src,<span class="keyword">size_t</span> num)</span></span>;</span><br><span class="line"><span class="comment">//从src地址开始拷贝num个字节到dst指向的内存区域。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1,<span class="keyword">const</span> <span class="keyword">void</span> *ptr2,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">//比较两个区域内存是否是一样的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dst,<span class="keyword">int</span> value,<span class="keyword">size_t</span> num)</span></span>;</span><br><span class="line"><span class="comment">//从dst开始num个字节的内存区域，设置成value。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="文件I-O"><span class="post-title-index">1.9. </span><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><h3 id="C-方式"><span class="post-title-index">1.9.1. </span><a href="#C-方式" class="headerlink" title="C++方式"></a>C++方式</h3><h4 id="输入输出流"><span class="post-title-index">1.9.1.1. </span><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><h4 id="文件"><span class="post-title-index">1.9.1.2. </span><a href="#文件" class="headerlink" title="文件"></a>文件</h4><ul>
<li><p><strong>打开/关闭文件流</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><fstream></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">   	ofstream ofs;</span><br><span class="line">    ofs.open(<span class="string">"data.txt"</span>,ios::out|ios::nocreate);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.is_open()){</span><br><span class="line">        <span class="built_in">cout</span><<<span class="string">"Failed to open file"</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//succeed in opening</span></span><br><span class="line">        ofs.close();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>对ASCII文件的操作</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对ASCII文件的文件流的操作和<span class="built_in">cin</span>、<span class="built_in">cout</span>一样。</span><br><span class="line">同样有:</span><br><span class="line">get、getline、put、eof、peak、putback、ignore这些成员函数。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>对二进制文件的操作</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"><span class="comment">//从文件流中读</span></span><br><span class="line"><span class="comment">//文件流对象名.read(buf首地址，字节长度)</span></span><br><span class="line">ifs.read(buf,size);  <span class="comment">//从文件中读取size个字节，放在</span></span><br><span class="line"><span class="comment">//往文件流中写</span></span><br><span class="line"><span class="comment">//文件流对象名.write(buf首地址，字节长度)</span></span><br><span class="line">ofs.write(buf,size);  <span class="comment">//将buf中的连续size个字节写入文件中。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="C方式"><span class="post-title-index">1.9.2. </span><a href="#C方式" class="headerlink" title="C方式"></a>C方式</h3><h4 id="文件-1"><span class="post-title-index">1.9.2.1. </span><a href="#文件-1" class="headerlink" title="文件"></a>文件</h4><ul>
<li><p><strong>文件指针FILE *</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><cstdio></span></span></span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="comment">//fp=fopen(文件名，打开方式)</span></span><br><span class="line">fp=fopen(<span class="string">"data.txt"</span>,<span class="string">"rb"</span>);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>​        </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">打开方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r/w</td>
<td style="text-align:center">只读/只写打开</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">可读可写</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">追加</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">二进制方式</td>
</tr>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:center">文本方式（缺省）</td>
</tr>
</tbody>
</table>
</div>
</body></html>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Mi HD
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://primemhd.tech/interview-cpp.html" title="面试知识：C++">https://primemhd.tech/interview-cpp.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/OpenVINO%E5%A4%A7%E5%B8%88.html" rel="next" title="OpenVINO大师">
      OpenVINO大师 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-专题复习"><span class="nav-number">1.</span> <span class="nav-text">1. C++专题复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#细碎知识"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 细碎知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-的关键字"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1. C++的关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1.1. static</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.1.2. const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.1.3. this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">1.1.1.4. inline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">1.1.1.5. volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-pack-n"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">1.1.1.6. #pragma pack(n)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extern-quot-C-quot"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">1.1.1.7. extern &quot;C&quot;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#union共用体-和机器大小端"><span class="nav-number">1.1.1.8.</span> <span class="nav-text">1.1.1.8. union共用体(和机器大小端)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enum枚举类型"><span class="nav-number">1.1.1.9.</span> <span class="nav-text">1.1.1.9. enum枚举类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit"><span class="nav-number">1.1.1.10.</span> <span class="nav-text">1.1.1.10. explicit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sizeof"><span class="nav-number">1.1.1.11.</span> <span class="nav-text">1.1.1.11. sizeof()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#friend"><span class="nav-number">1.1.1.12.</span> <span class="nav-text">1.1.1.12. friend</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exit"><span class="nav-number">1.1.1.13.</span> <span class="nav-text">1.1.1.13. exit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#using"><span class="nav-number">1.1.1.14.</span> <span class="nav-text">1.1.1.14. using</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-catch"><span class="nav-number">1.1.1.15.</span> <span class="nav-text">1.1.1.15. try catch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#size-t"><span class="nav-number">1.1.1.16.</span> <span class="nav-text">1.1.1.16. size_t</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NULL"><span class="nav-number">1.1.1.17.</span> <span class="nav-text">1.1.1.17. NULL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-的内存分布"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2. C++的内存分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中的变量"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3. C++中的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符重载"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4. 操作符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成员函数运算符重载"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.1.4.1. 成员函数运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#友元函数运算符重载"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.1.4.2. 友元函数运算符重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件编译"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.1.5. 条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝与深拷贝（赋值与复制）"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.1.6. 浅拷贝与深拷贝（赋值与复制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数列表"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.1.7. 可变参数列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象专题"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 类与对象专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小知识"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1. 小知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2. 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据成员的初始化"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1.2.2.1. 数据成员的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的调用"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">1.2.2.2. 构造函数的调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3. 析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#析构函数注意问题"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1.2.3.1. 析构函数注意问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#析构函数的调用时机"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">1.2.3.2. 析构函数的调用时机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承派生专题"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 继承派生专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. 虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空虚函数"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.3.1.1. - 空虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#纯虚函数与抽象类"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1.3.1.2. - 纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数表"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">1.3.1.3. - 虚函数表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL专题"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. STL专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. 分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string类"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2. string类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sizeof-1"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1.4.2.1. sizeof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string长度"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">1.4.2.2. string长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列容器"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3. 序列容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联容器"><span class="nav-number">1.4.4.</span> <span class="nav-text">1.4.4. 关联容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存-amp-指针专题"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. 内存&amp;指针专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针和引用"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1. 指针和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">1.5.1.1. 引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#左值-右值引用"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">1.5.1.2. 左值&#x2F;右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动语义"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">1.5.1.3. 移动语义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态内存分配与管理"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2. 动态内存分配与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc、calloc、realloc"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">1.5.2.1. malloc、calloc、realloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new、delete"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">1.5.2.2. new、delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#operator-new和new-operator的区别"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">1.5.2.3. operator new和new operator的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限定对象只能在堆上（栈上）"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">1.5.2.4. 限定对象只能在堆上（栈上）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要智能指针"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">1.5.3.1. 为什么需要智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#auto-ptr-被c-11弃用"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">1.5.3.2. auto_ptr(被c++11弃用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">1.5.3.3. unique_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">1.5.3.4. shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-ptr"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">1.5.3.5. weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动语义-1"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5.4. 移动语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型编程"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. 泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模板"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. 函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模板"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 类模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-多线程"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. C++多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#phtread"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.7.1. phtread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">1.8.</span> <span class="nav-text">1.8. 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-amp-类"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.8.1. 数据结构&amp;类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#char-和char"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">1.8.1.1. char[ ]和char*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string类-1"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">1.8.1.2. string类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串处理函数str"><span class="nav-number">1.8.2.</span> <span class="nav-text">1.8.2. 字符串处理函数str</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件I-O"><span class="nav-number">1.9.</span> <span class="nav-text">1.9. 文件I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-方式"><span class="nav-number">1.9.1.</span> <span class="nav-text">1.9.1. C++方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入输出流"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">1.9.1.1. 输入输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">1.9.1.2. 文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C方式"><span class="nav-number">1.9.2.</span> <span class="nav-text">1.9.2. C方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件-1"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">1.9.2.1. 文件</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mi HD"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mi HD</p>
  <div class="site-description" itemprop="description">Truth and Transparency. 简单可依赖。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PrimeMHD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PrimeMHD" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:primemhd@foxmail.com" title="E-Mail → mailto:primemhd@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/intelligent.mi" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;intelligent.mi" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mi HD</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f9a7860fd0377b0" async="async"></script>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'P8FEvuQgjEvJlyauAdThzmno-gzGzoHsz',
      appKey     : 'Y6y7RduGPwDw9Yl8n7Xq1ldg',
      placeholder: "Just go go",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
